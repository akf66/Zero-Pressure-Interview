// Code generated by Kitex v0.15.3. DO NOT EDIT.

package questionservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	base "zpi/server/shared/kitex_gen/base"
	question "zpi/server/shared/kitex_gen/question"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"HealthCheck": kitex.NewMethodInfo(
		healthCheckHandler,
		newQuestionServiceHealthCheckArgs,
		newQuestionServiceHealthCheckResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"CreateQuestion": kitex.NewMethodInfo(
		createQuestionHandler,
		newQuestionServiceCreateQuestionArgs,
		newQuestionServiceCreateQuestionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"UpdateQuestion": kitex.NewMethodInfo(
		updateQuestionHandler,
		newQuestionServiceUpdateQuestionArgs,
		newQuestionServiceUpdateQuestionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"DeleteQuestion": kitex.NewMethodInfo(
		deleteQuestionHandler,
		newQuestionServiceDeleteQuestionArgs,
		newQuestionServiceDeleteQuestionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"GetQuestion": kitex.NewMethodInfo(
		getQuestionHandler,
		newQuestionServiceGetQuestionArgs,
		newQuestionServiceGetQuestionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"GetQuestionList": kitex.NewMethodInfo(
		getQuestionListHandler,
		newQuestionServiceGetQuestionListArgs,
		newQuestionServiceGetQuestionListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"GetCategories": kitex.NewMethodInfo(
		getCategoriesHandler,
		newQuestionServiceGetCategoriesArgs,
		newQuestionServiceGetCategoriesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"GetRandomQuestions": kitex.NewMethodInfo(
		getRandomQuestionsHandler,
		newQuestionServiceGetRandomQuestionsArgs,
		newQuestionServiceGetRandomQuestionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"FavoriteQuestion": kitex.NewMethodInfo(
		favoriteQuestionHandler,
		newQuestionServiceFavoriteQuestionArgs,
		newQuestionServiceFavoriteQuestionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"UnfavoriteQuestion": kitex.NewMethodInfo(
		unfavoriteQuestionHandler,
		newQuestionServiceUnfavoriteQuestionArgs,
		newQuestionServiceUnfavoriteQuestionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"GetFavoriteQuestions": kitex.NewMethodInfo(
		getFavoriteQuestionsHandler,
		newQuestionServiceGetFavoriteQuestionsArgs,
		newQuestionServiceGetFavoriteQuestionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"AddQuestionNote": kitex.NewMethodInfo(
		addQuestionNoteHandler,
		newQuestionServiceAddQuestionNoteArgs,
		newQuestionServiceAddQuestionNoteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"GetQuestionNote": kitex.NewMethodInfo(
		getQuestionNoteHandler,
		newQuestionServiceGetQuestionNoteArgs,
		newQuestionServiceGetQuestionNoteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
}

var (
	questionServiceServiceInfo                = NewServiceInfo()
	questionServiceServiceInfoForClient       = NewServiceInfoForClient()
	questionServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return questionServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return questionServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return questionServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "QuestionService"
	handlerType := (*question.QuestionService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "question",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Thrift,
		KiteXGenVersion: "v0.15.3",
		Extra:           extra,
	}
	return svcInfo
}

func healthCheckHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	_ = arg.(*question.QuestionServiceHealthCheckArgs)
	realResult := result.(*question.QuestionServiceHealthCheckResult)
	success, err := handler.(question.QuestionService).HealthCheck(ctx)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceHealthCheckArgs() interface{} {
	return question.NewQuestionServiceHealthCheckArgs()
}

func newQuestionServiceHealthCheckResult() interface{} {
	return question.NewQuestionServiceHealthCheckResult()
}

func createQuestionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceCreateQuestionArgs)
	realResult := result.(*question.QuestionServiceCreateQuestionResult)
	success, err := handler.(question.QuestionService).CreateQuestion(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceCreateQuestionArgs() interface{} {
	return question.NewQuestionServiceCreateQuestionArgs()
}

func newQuestionServiceCreateQuestionResult() interface{} {
	return question.NewQuestionServiceCreateQuestionResult()
}

func updateQuestionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceUpdateQuestionArgs)
	realResult := result.(*question.QuestionServiceUpdateQuestionResult)
	success, err := handler.(question.QuestionService).UpdateQuestion(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceUpdateQuestionArgs() interface{} {
	return question.NewQuestionServiceUpdateQuestionArgs()
}

func newQuestionServiceUpdateQuestionResult() interface{} {
	return question.NewQuestionServiceUpdateQuestionResult()
}

func deleteQuestionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceDeleteQuestionArgs)
	realResult := result.(*question.QuestionServiceDeleteQuestionResult)
	success, err := handler.(question.QuestionService).DeleteQuestion(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceDeleteQuestionArgs() interface{} {
	return question.NewQuestionServiceDeleteQuestionArgs()
}

func newQuestionServiceDeleteQuestionResult() interface{} {
	return question.NewQuestionServiceDeleteQuestionResult()
}

func getQuestionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceGetQuestionArgs)
	realResult := result.(*question.QuestionServiceGetQuestionResult)
	success, err := handler.(question.QuestionService).GetQuestion(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceGetQuestionArgs() interface{} {
	return question.NewQuestionServiceGetQuestionArgs()
}

func newQuestionServiceGetQuestionResult() interface{} {
	return question.NewQuestionServiceGetQuestionResult()
}

func getQuestionListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceGetQuestionListArgs)
	realResult := result.(*question.QuestionServiceGetQuestionListResult)
	success, err := handler.(question.QuestionService).GetQuestionList(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceGetQuestionListArgs() interface{} {
	return question.NewQuestionServiceGetQuestionListArgs()
}

func newQuestionServiceGetQuestionListResult() interface{} {
	return question.NewQuestionServiceGetQuestionListResult()
}

func getCategoriesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceGetCategoriesArgs)
	realResult := result.(*question.QuestionServiceGetCategoriesResult)
	success, err := handler.(question.QuestionService).GetCategories(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceGetCategoriesArgs() interface{} {
	return question.NewQuestionServiceGetCategoriesArgs()
}

func newQuestionServiceGetCategoriesResult() interface{} {
	return question.NewQuestionServiceGetCategoriesResult()
}

func getRandomQuestionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceGetRandomQuestionsArgs)
	realResult := result.(*question.QuestionServiceGetRandomQuestionsResult)
	success, err := handler.(question.QuestionService).GetRandomQuestions(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceGetRandomQuestionsArgs() interface{} {
	return question.NewQuestionServiceGetRandomQuestionsArgs()
}

func newQuestionServiceGetRandomQuestionsResult() interface{} {
	return question.NewQuestionServiceGetRandomQuestionsResult()
}

func favoriteQuestionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceFavoriteQuestionArgs)
	realResult := result.(*question.QuestionServiceFavoriteQuestionResult)
	success, err := handler.(question.QuestionService).FavoriteQuestion(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceFavoriteQuestionArgs() interface{} {
	return question.NewQuestionServiceFavoriteQuestionArgs()
}

func newQuestionServiceFavoriteQuestionResult() interface{} {
	return question.NewQuestionServiceFavoriteQuestionResult()
}

func unfavoriteQuestionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceUnfavoriteQuestionArgs)
	realResult := result.(*question.QuestionServiceUnfavoriteQuestionResult)
	success, err := handler.(question.QuestionService).UnfavoriteQuestion(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceUnfavoriteQuestionArgs() interface{} {
	return question.NewQuestionServiceUnfavoriteQuestionArgs()
}

func newQuestionServiceUnfavoriteQuestionResult() interface{} {
	return question.NewQuestionServiceUnfavoriteQuestionResult()
}

func getFavoriteQuestionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceGetFavoriteQuestionsArgs)
	realResult := result.(*question.QuestionServiceGetFavoriteQuestionsResult)
	success, err := handler.(question.QuestionService).GetFavoriteQuestions(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceGetFavoriteQuestionsArgs() interface{} {
	return question.NewQuestionServiceGetFavoriteQuestionsArgs()
}

func newQuestionServiceGetFavoriteQuestionsResult() interface{} {
	return question.NewQuestionServiceGetFavoriteQuestionsResult()
}

func addQuestionNoteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceAddQuestionNoteArgs)
	realResult := result.(*question.QuestionServiceAddQuestionNoteResult)
	success, err := handler.(question.QuestionService).AddQuestionNote(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceAddQuestionNoteArgs() interface{} {
	return question.NewQuestionServiceAddQuestionNoteArgs()
}

func newQuestionServiceAddQuestionNoteResult() interface{} {
	return question.NewQuestionServiceAddQuestionNoteResult()
}

func getQuestionNoteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*question.QuestionServiceGetQuestionNoteArgs)
	realResult := result.(*question.QuestionServiceGetQuestionNoteResult)
	success, err := handler.(question.QuestionService).GetQuestionNote(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newQuestionServiceGetQuestionNoteArgs() interface{} {
	return question.NewQuestionServiceGetQuestionNoteArgs()
}

func newQuestionServiceGetQuestionNoteResult() interface{} {
	return question.NewQuestionServiceGetQuestionNoteResult()
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) HealthCheck(ctx context.Context) (r *base.HealthCheckResponse, err error) {
	var _args question.QuestionServiceHealthCheckArgs
	var _result question.QuestionServiceHealthCheckResult
	if err = p.c.Call(ctx, "HealthCheck", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateQuestion(ctx context.Context, req *question.CreateQuestionRequest) (r *question.CreateQuestionResponse, err error) {
	var _args question.QuestionServiceCreateQuestionArgs
	_args.Req = req
	var _result question.QuestionServiceCreateQuestionResult
	if err = p.c.Call(ctx, "CreateQuestion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateQuestion(ctx context.Context, req *question.UpdateQuestionRequest) (r *question.UpdateQuestionResponse, err error) {
	var _args question.QuestionServiceUpdateQuestionArgs
	_args.Req = req
	var _result question.QuestionServiceUpdateQuestionResult
	if err = p.c.Call(ctx, "UpdateQuestion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteQuestion(ctx context.Context, req *question.DeleteQuestionRequest) (r *question.DeleteQuestionResponse, err error) {
	var _args question.QuestionServiceDeleteQuestionArgs
	_args.Req = req
	var _result question.QuestionServiceDeleteQuestionResult
	if err = p.c.Call(ctx, "DeleteQuestion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetQuestion(ctx context.Context, req *question.GetQuestionRequest) (r *question.GetQuestionResponse, err error) {
	var _args question.QuestionServiceGetQuestionArgs
	_args.Req = req
	var _result question.QuestionServiceGetQuestionResult
	if err = p.c.Call(ctx, "GetQuestion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetQuestionList(ctx context.Context, req *question.GetQuestionListRequest) (r *question.GetQuestionListResponse, err error) {
	var _args question.QuestionServiceGetQuestionListArgs
	_args.Req = req
	var _result question.QuestionServiceGetQuestionListResult
	if err = p.c.Call(ctx, "GetQuestionList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetCategories(ctx context.Context, req *question.GetCategoriesRequest) (r *question.GetCategoriesResponse, err error) {
	var _args question.QuestionServiceGetCategoriesArgs
	_args.Req = req
	var _result question.QuestionServiceGetCategoriesResult
	if err = p.c.Call(ctx, "GetCategories", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetRandomQuestions(ctx context.Context, req *question.GetRandomQuestionsRequest) (r *question.GetRandomQuestionsResponse, err error) {
	var _args question.QuestionServiceGetRandomQuestionsArgs
	_args.Req = req
	var _result question.QuestionServiceGetRandomQuestionsResult
	if err = p.c.Call(ctx, "GetRandomQuestions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FavoriteQuestion(ctx context.Context, req *question.FavoriteQuestionRequest) (r *question.FavoriteQuestionResponse, err error) {
	var _args question.QuestionServiceFavoriteQuestionArgs
	_args.Req = req
	var _result question.QuestionServiceFavoriteQuestionResult
	if err = p.c.Call(ctx, "FavoriteQuestion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnfavoriteQuestion(ctx context.Context, req *question.UnfavoriteQuestionRequest) (r *question.UnfavoriteQuestionResponse, err error) {
	var _args question.QuestionServiceUnfavoriteQuestionArgs
	_args.Req = req
	var _result question.QuestionServiceUnfavoriteQuestionResult
	if err = p.c.Call(ctx, "UnfavoriteQuestion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFavoriteQuestions(ctx context.Context, req *question.GetFavoriteQuestionsRequest) (r *question.GetFavoriteQuestionsResponse, err error) {
	var _args question.QuestionServiceGetFavoriteQuestionsArgs
	_args.Req = req
	var _result question.QuestionServiceGetFavoriteQuestionsResult
	if err = p.c.Call(ctx, "GetFavoriteQuestions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddQuestionNote(ctx context.Context, req *question.AddQuestionNoteRequest) (r *question.AddQuestionNoteResponse, err error) {
	var _args question.QuestionServiceAddQuestionNoteArgs
	_args.Req = req
	var _result question.QuestionServiceAddQuestionNoteResult
	if err = p.c.Call(ctx, "AddQuestionNote", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetQuestionNote(ctx context.Context, req *question.GetQuestionNoteRequest) (r *question.GetQuestionNoteResponse, err error) {
	var _args question.QuestionServiceGetQuestionNoteArgs
	_args.Req = req
	var _result question.QuestionServiceGetQuestionNoteResult
	if err = p.c.Call(ctx, "GetQuestionNote", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
